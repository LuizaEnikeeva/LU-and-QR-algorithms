#include <iostream>
#include <exception>
#include <fstream>
#include <string>
#include <vector>
#include <cstring>
#include <cmath>
#include <complex>
#include "header.h"

/*
    Эта программа может пострить разложения LU, QR и по методу Холецкого,
    с помощью которых может решить СЛАУ.
*/
using namespace std;

void make_lu(const char* path); //строит LU разложение
void make_lu_upgrade(const char* path); //строит LU разложение с возможностью переставлять строки матрицы, чтобы на каждой итерации выбирался наибольший ведущий член
void lu_gauss(const char* path); //Решает СЛАУ с помощью LU разложения
void make_chol(const char* path); //строит разложение по методу Холецкого
void chol_gauss(const char* path); //решает СЛАУ с помощью метода Холецкого
void make_qr(const char* path); //строит QR разложение
void qr_gauss(const char* path); //решает СЛАУ с помощью QR разложения

/*
    На вход принимается файл с матрицами с именем типа Amat1.m (имя обЪекта (А) + тип объекта (матрица=mat) + номер объекта (1))
    Вещественная матрица должна быть следуещего вида:
    A = ...
        [x11 x12 x13;
         x21 x22 x23;
         x31 x32 x33];
    Первая строка состоит из имени матрицы, знака равно и трех точек.
    Числа в матрицы находятся внутри квадратных скобках,
    Знак ";" обозначает конец строки.

    Пример комплексной матрицы:
    A = complex([x11 x12;
        x21 x22],[x11i x12i;
        x21i x22i]);
    Здесь перед началом матрицы нужен индефикатор "complex",
    сама матрица заключна в круглых скобках, в которой
    действительная часть - это числа в первых квадратных скобках,
    а  мнимая часть - те, которые во второй. Эти части разделяются запятыми.

    Для СЛАУ используется вектор свободных членов с именем типа bvec1.m (имя обЪекта (b) + тип объекта (вектор=vec) + номер объекта (1))

*/
int main()
{
    qr_gauss("Amat2.m");
    return 0;
}
